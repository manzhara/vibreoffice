<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="vibreoffice" script:language="StarBasic">
&apos; vibreoffice - Vi Mode for LibreOffice/OpenOffice
&apos;
&apos; The MIT License (MIT)
&apos;
&apos; Copyright (c) 2014 Sean Yeh
&apos;
&apos; Permission is hereby granted, free of charge, to any person obtaining a copy
&apos; of this software and associated documentation files (the &quot;Software&quot;), to deal
&apos; in the Software without restriction, including without limitation the rights
&apos; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&apos; copies of the Software, and to permit persons to whom the Software is
&apos; furnished to do so, subject to the following conditions:
&apos;
&apos; The above copyright notice and this permission notice shall be included in
&apos; all copies or substantial portions of the Software.
&apos;
&apos; THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&apos; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&apos; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&apos; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&apos; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&apos; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&apos; THE SOFTWARE.

&apos; 2020 Yamsu 
&apos; Added Support for Librecalc
&apos;
&apos; Added APP() :: Able to check if running Calc, Writer, or Other (Impress, etc.)
&apos; Added simulate_KeyPress_Char() :: Allow generation of key press/release to perform desired motions and operations.
&apos; Added simulate_KeyPress() :: Actually carries out key generation
&apos; Added KEYS() :: Provides key infomation
&apos; Added MODS() :: Provide key modifier information
&apos; TODO Execute as url :: Execute link through web browser
&apos; TODO Borders :: Generate border
&apos; TODO Normal for Intracell movement ::
&apos;
&apos; Incorporated branch from fedorov-ao (Read On)
&apos;
&apos; 2018 axf 
&apos; An attempt to revitalize a useful LibreOffice plugin
&apos; Can be used, but is a work-in-progress so far

&apos; Added Russian keyboard mapping (works in almost all cases)
&apos; Fixed key release processing: releasing of non-char keys is now not consumed
&apos; Fixed char search
&apos; Fixed moving to end of word (e). Moves to the first space after the word.
&apos; Added moving to end of previous word (E). Also moves to the first space after the word. 
&apos; Added search repeating (n and N) 
&apos; Mapped redo to U
&apos; Status bar now displays full vibreoffice state for given frame
&apos; Refactored key translation functions
&apos; Added [c,d][a,i]&lt;char&gt; - will change or delete text fragment surrounded by &lt;char&gt;
&apos; Changed multiplied yank processing: now selects the whole region based on multiplied movement, then yanks. Allows to paste the whole region instead of its last part only.
&apos; Added / and ? searches. String used to search with these is treated as last search and can be used by n and N. 
&apos; Added backspace emulation, called with X
&apos; Replaced string mode id with integer. Should work faster, especially in input.
&apos; Added selection active end swap in visual mode (o).
&apos; Optimized key processing in insert mode.
&apos; Added input logging, log is displayed and cleared by Alt+=
&apos; Added the ability to display the character currently selected by cursor in normal mode
&apos;  If char is printable, shows it as-is, if not - shows its &lt;code&gt;, if empty - shows &lt;&gt;
&apos;  Called by Alt+-
&apos; Added skipping over control and zero-length chars. Downside: cannot join lines easily. Have to go to beggining of next line and press &quot;X&quot;
&apos; Fixed character swapping bug in insert mode by consuming all input and directly using cursor for output
&apos; Fixed dd and cc not working on the last line
&apos; Fixing initialization. Unfortunately, cannot add key handlers and init status bars of all
&apos; currently open windows due to LibreOffice bug (also cannot deinit)
&apos; Thus assuming that vibreoffice is initialized and deinitialized 
&apos; when only one, currently active window is opened
&apos; Added support for multiple windows. Apparently works, but needs cleanup. Vibreoffice is switched into normal mode
&apos; when bringing window in focus
&apos; Fixed s
&apos; Fixed annotation zero-length &quot;char&quot; handling during hjkl movement
&apos; Optimized selection ends swap
&apos; Added polling-based reinitialization on changing windows
&apos; Shift+ESC, as well as &quot;toggle Vbreoffice&quot; menu entry, toggles Vibreoffice

&apos; BUG Annotations break repeated h/l movement
&apos; BUG Anntoations break selection ends swap
&apos; BUG b and e mishadle dashes and periods. Caused by incorrect behaviour of XTextCursor::gotoNext/PreviousWord()
&apos; BUG Searching with f and F behaves incorrectly in visual mode
&apos; TODO Add separate status bar for vibreoffice. Not as easy as it seems.
&apos; TODO Split ProcessMovementKey() into several specialized functions (hjkl movement, word-based movement...).
&apos; Pass number of iterations to these functions to handle repetitions internally.
&apos; 

&apos; Following option allows the use of ActiveCell, but doesn&apos;t work&apos;
&apos;Option VBASupport 1 

Option Explicit
&apos; --------
&apos; Globals
&apos; --------
global VIBREOFFICE_STARTED as boolean &apos; Defaults to False
global VIBREOFFICE_ENABLED as boolean &apos; Defaults to False

global oXKeyHandler as object
global oListener as object
global oCurrentFrame as object

&apos; Global State (Value are preserved even when the marco is not running)
const M_NORMAL = 0
const M_INSERT = 1
const M_VISUAL = 2
const M_VISUAL_LINE = 3
const M_DISABLED = 254
const M_BAD = 255
global MODE as integer
global TEST as integer
global OLD_MODE as integer

global VIEW_CURSOR as object
global TEXT_CURSOR as object
global MULTIPLIER as integer
global VISUAL_BASE as object &apos; Position of line that is first selected when 
                             &apos; VISUAL_LINE mode is entered
&apos;global ACTIVE_SHEET as object
&apos;global ACTIVE_CELL as object
&apos;global APP as string
global LAST_SEARCH as string

global logged2 as string

&apos; -----------
&apos; Key Generation for Calc 
&apos; -----------
Public Function MODS (key as String)
	Select Case key
		Case &quot;SHIFT&quot;:
			MODS = 1
		Case &quot;CTRL&quot;: 
			&apos;CMD for Mac OS&apos;
			MODS = 2
		Case &quot;ALT&quot;:
			MODS = 4
		Case &quot;MACCTRL&quot;:
			&apos;CTRL for Mac OS&apos;
			MODS = 8
	End Select
End Function

Public Function KEYS( key as String, Optional modifier as Integer )
Select Case key
	Case &quot;ESCAPE&quot;:
		KEYS = Array(9,	  com.sun.star.awt.Key.ESCAPE,   0)
	Case &quot;RETURN&quot;:
		KEYS = Array(13,  com.sun.star.awt.Key.RETURN,   0)
	Case &quot;F&quot;:
		KEYS = Array(41,	  com.sun.star.awt.Key.F,   0)
	Case &quot;F2&quot;:
		KEYS = Array(68,  com.sun.star.awt.Key.F2,       0)
	Case &quot;DELETE&quot;:
		KEYS = Array(91,  com.sun.star.awt.Key.DELETE,   0)
	Case &quot;HOME&quot;:
		KEYS = Array(110, com.sun.star.awt.Key.HOME,     0)
	Case &quot;UP&quot;:
		KEYS = Array(111, com.sun.star.awt.Key.UP,       0)
	Case &quot;PAGEUP&quot;:
		KEYS = Array(112, com.sun.star.awt.Key.PAGEUP,   0)
	Case &quot;LEFT&quot;:
		KEYS = Array(113, com.sun.star.awt.Key.LEFT,     0)
	Case &quot;RIGHT&quot;:
		KEYS = Array(114, com.sun.star.awt.Key.RIGHT,    0)
	Case &quot;END&quot;:
		KEYS = Array(115, com.sun.star.awt.Key.END,      0)
	Case &quot;DOWN&quot;:
		KEYS = Array(116, com.sun.star.awt.Key.DOWN,     0)
	Case &quot;PAGEDOWN&quot;:
		KEYS = Array(117, com.sun.star.awt.Key.PAGEDOWN, 0)
End Select
If Not IsMissing(modifier) Then KEYS(2)=modifier
End Function

Sub simulate_KeyPress_Char( key as String, Optional modifier as String, Optional modifier2 as String, Optional modifier3 as String)
REM Simulate a RETURN Key press ( and -release ) in the current Window.
REM NB. This can cause the triggering of window elements.
    Dim oKeyEvent As New com.sun.star.awt.KeyEvent
	Dim KeyData(3) As Integer
	Dim finalModfiers As Integer
	finalModfiers = 0
	If Not IsMissing(modifier) Then finalModfiers = finalModfiers + MODS(modifier)
	If Not IsMissing(modifier2) Then finalModfiers = finalModfiers + MODS(modifier2)
	If Not IsMissing(modifier3) Then finalModfiers = finalModfiers + MODS(modifier3)
	KeyData = KEYS(key, finalModfiers)

    oKeyEvent.Modifiers = KeyData(2)     REM A combination of com.sun.star.awt.KeyModifier.
    oKeyEvent.KeyCode   = KeyData(1)               REM 1280.
    oKeyEvent.KeyChar   = chr( KeyData(0) )
    simulate_KeyPress( oKeyEvent )
End Sub

Sub simulate_KeyPress( oKeyEvent As com.sun.star.awt.KeyEvent )
REM Simulate a Key press ( and -release ) in the current Window.
REM NB. This can cause the triggering of window elements.
REM For example if there is a button currently selected in your form, and you call this method
REM while passing the KeyEvent for RETURN, then that button will be activated.
    If Not IsNull( oKeyEvent ) Then
		removeKeyHandlerFromModels()
        Dim oWindow As Object, oToolkit As Object
        oWindow = ThisComponent.CurrentController.Frame.getContainerWindow()
        oKeyEvent.Source = oWindow      
        oToolkit = oWindow.getToolkit()         REM com.sun.star.awt.Toolkit
        oToolkit.keyPress( oKeyEvent )          REM methods of XToolkitRobot.
		oToolkit.keyRelease( oKeyEvent )
		addKeyHandlerToModels()
    End If
End Sub

&apos; -----------
&apos; Singletons
&apos; -----------
Sub setCursor
	VIEW_CURSOR = Nothing
	dim oCurrentController
	oCurrentController = getCurrentController()
	If oCurrentController is Nothing Then
		VIEW_CURSOR = Nothing
	Else
	If APP() &lt;&gt; &quot;CALC&quot; Then
	    VIEW_CURSOR = oCurrentController.getViewCursor()
	Else
		VIEW_CURSOR = Nothing
	End If
	End If
End Sub

Function getCursor
	If APP() &lt;&gt; &quot;CALC&quot; Then
		getCursor = VIEW_CURSOR
	Else
		getCursor = Nothing
	End If
End Function

Sub setTextCursor
	If APP() &lt;&gt; &quot;CALC&quot; Then
		On Error Goto ErrorHandler
		dim oCursor
		oCursor = getCursor()
		dim oText 
		oText = oCursor.getText()
		TEXT_CURSOR = oText.createTextCursorByRange(oCursor)
		Exit Sub
		
	ErrorHandler:
		&apos; Text Cursor does not work in some instances, such as in Annotations
		TEXT_CURSOR = Nothing
	Else
		TEXT_CURSOR = Nothing
	End If
End Sub

Function getTextCursor
	setTextCursor() &apos; temp
    getTextCursor = TEXT_CURSOR
End Function

Function getCurrentController()
	On Error Goto ErrorHandler
	dim oComponent as object : oComponent = thisComponent
	getCurrentController = oComponent.getCurrentController()
	Exit Function
ErrorHandler:
	getCurrentController = Nothing
End Function	

private function printString(oCursor, s)
	dim l : l = len(s)
	oCursor.setString(s)
	oCursor.goRight(l, False)
end function

&apos; -----------------
&apos; Calc Related Function
&apos; -----------------

Function getSheet()
	getSheet = ThisComponent.CurrentSelection.getSpreadsheet
End Function

Function insertRow(Optional opt As Integer)
	REM 1 Below 0 for Above
	Dim sheet as Object
	Dim myRangeRaw as Object
	Dim Rs, Re
	Dim optL as Integer
	if IsMissing(opt) Then
		optL = 1 
	Else
		optL = opt
	End If

	sheet = getSheet()
	myRangeRaw = ThisComponent.getCurrentSelection.getRangeAddress
	Rs = myRangeRaw.startRow
    Re = myRangeRaw.endRow
    If optL = 1 Then
    	REM Below need to move down one cell
		sheet.Rows.insertByIndex(Rs+1, 1)
	Else
		REM Above
		sheet.Rows.insertByIndex(Re, 1)
	End If
End Function


Function removeRow()
	REM 1 Below 0 for Above
	Dim sheet as Object
	Dim myRangeRaw as Object
	Dim Rs, Re


	sheet = getSheet()
	myRangeRaw = ThisComponent.getCurrentSelection.getRangeAddress
	Rs = myRangeRaw.startRow
    Re = myRangeRaw.endRow

	sheet.Rows.removeByIndex(Re, 1)

End Function
&apos; -----------------
&apos; Helper Functions
&apos; -----------------
&apos; Returns mode name
Function getModeName(m)
	dim sModeName as string
	Select Case m
		Case M_NORMAL:
			sModeName = CStr(TEST)
		Case M_INSERT:
			sModeName = &quot;INSERT&quot;
		Case M_VISUAL:
			sModeName = &quot;VISUAL&quot;
		Case M_VISUAL_LINE:
			sModeName = &quot;VISUAL_LINE&quot;
		Case M_BAD:
			sModeName = &quot;BAD&quot;
		Case M_DISABLED:
			sModeName = &quot;DISABLED&quot;
		Case Else:
			sModeName = &quot;BAD&quot;								
	End Select
	getModeName = sModeName
End Function

&apos; Returns key by non-zero code
Function getLatinKeyCharByCode(oEvent)
    dim keyChar
	keyChar = asc(0)
    If (oEvent.modifiers and 1) = 0 Then
        Select Case oEvent.keyCode
            case 1311: 
                keyChar = &quot;`&quot;
            case 257: 
                keyChar = &quot;1&quot;
            case 258: 
                keyChar = &quot;2&quot;
            case 259: 
                keyChar = &quot;3&quot;
            case 260: 
                keyChar = &quot;4&quot;
            case 261: 
                keyChar = &quot;5&quot;
            case 262:
                keyChar = &quot;6&quot;
            case 263:
                keyChar = &quot;7&quot;
            case 264:
                keyChar = &quot;8&quot;
            case 265:
                keyChar = &quot;9&quot;
            case 256:
                keyChar = &quot;0&quot;
            case 1288:
                keyChar = &quot;-&quot;
            case 1295:
                keyChar = &quot;=&quot;
            case 0:
                keyChar = &quot;\&quot;
            case 528:
                keyChar = &quot;q&quot;
            case 534:
                keyChar = &quot;w&quot;
            case 516:
                keyChar = &quot;e&quot;
            case 529:
                keyChar = &quot;r&quot;
            case 531:
                keyChar = &quot;t&quot;
            case 536:
                keyChar = &quot;y&quot;
            case 532:
                keyChar = &quot;u&quot;
            case 520:
                keyChar = &quot;i&quot;
            case 526:
                keyChar = &quot;o&quot;
            case 527:
                keyChar = &quot;p&quot;
            case 1315:
                keyChar = &quot;[&quot;
            case 1316:
                keyChar = &quot;]&quot;
            case 512:
                keyChar = &quot;a&quot;
            case 530:
                keyChar = &quot;s&quot;
            case 515:
                keyChar = &quot;d&quot;
            case 517:
                keyChar = &quot;f&quot;
            case 518:
                keyChar = &quot;g&quot;
            case 519:
                keyChar = &quot;h&quot;
            case 521:
                keyChar = &quot;j&quot;
            case 522:
                keyChar = &quot;k&quot;
            case 523:
                keyChar = &quot;l&quot;
            case 1317:
                keyChar = &quot;;&quot;
            case 1318:
                keyChar = &quot;&apos;&quot;
            case 537:
                keyChar = &quot;z&quot;
            case 535:
                keyChar = &quot;x&quot;
            case 514:
                keyChar = &quot;c&quot;
            case 533:
                keyChar = &quot;v&quot;
            case 513:
                keyChar = &quot;b&quot;
            case 525:
                keyChar = &quot;n&quot;
            case 524:
                keyChar = &quot;m&quot;
            case 1292:
                keyChar = &quot;,&quot;
            case 1291:
                keyChar = &quot;.&quot;
            case 1290:
                keyChar = &quot;/&quot;
            case 1284:
                keyChar = &quot; &quot;
        End Select
    Else
        Select Case oEvent.keyCode
            case 1311:
                keyChar = &quot;~&quot;
            case 257:
                keyChar = &quot;!&quot;
            case 258:
                keyChar = &quot;@&quot;
            case 259:
                keyChar = &quot;#&quot;
            case 260:
                keyChar = &quot;$&quot;
            case 261:
                keyChar = &quot;%&quot;
            case 262:
                keyChar = &quot;^&quot;
            case 263:
                keyChar = &quot;&amp;&quot;
            case 264:
                keyChar = &quot;*&quot;
            case 265:
                keyChar = &quot;(&quot;
            case 256:
                keyChar = &quot;)&quot;
            case 1288:
                keyChar = &quot;_&quot;
            case 1295:
                keyChar = &quot;+&quot;
            case 528:
                keyChar = &quot;Q&quot;
            case 534:
                keyChar = &quot;W&quot;
            case 516:
                keyChar = &quot;E&quot;
            case 529:
                keyChar = &quot;R&quot;
            case 531:
                keyChar = &quot;T&quot;
            case 536:
                keyChar = &quot;Y&quot;
            case 532:
                keyChar = &quot;U&quot;
            case 520:
                keyChar = &quot;I&quot;
            case 526:
                keyChar = &quot;O&quot;
            case 527:
                keyChar = &quot;P&quot;
            case 1315:
                keyChar = &quot;{&quot;
            case 1316:
                keyChar = &quot;}&quot;
            case 512:
                keyChar = &quot;A&quot;
            case 530:
                keyChar = &quot;S&quot;
            case 515:
                keyChar = &quot;D&quot;
            case 517:
                keyChar = &quot;F&quot;
            case 518:
                keyChar = &quot;G&quot;
            case 519:
                keyChar = &quot;H&quot;
            case 521:
                keyChar = &quot;J&quot;
            case 522:
                keyChar = &quot;K&quot;
            case 523:
                keyChar = &quot;L&quot;
            case 1317:
                keyChar = &quot;:&quot;
            case 1318:
                keyChar = chr(34)
            case 537:
                keyChar = &quot;Z&quot;
            case 535:
                keyChar = &quot;X&quot;
            case 514:
                keyChar = &quot;C&quot;
            case 533:
                keyChar = &quot;V&quot;
            case 513:
                keyChar = &quot;B&quot;
            case 525:
                keyChar = &quot;N&quot;
            case 524:
                keyChar = &quot;M&quot;
            case 1292:
                keyChar = &quot;&lt;&quot;
            case 1291:
                keyChar = &quot;&gt;&quot;
            case 1290:
                keyChar = &quot;?&quot;
            case 1284:
                keyChar = &quot; &quot;
        End Select
    End If
    getLatinKeyCharByCode = keyChar
End Function

Function getLatinKeyCharByRus(oEvent)
    dim keyChar
    keyChar = asc(0)
    If (oEvent.modifiers and 1) = 0 Then
        Select Case oEvent.keyCode
            case &quot;?&quot;:
                keyChar = &quot;[&quot;
            case &quot;?&quot;:
                keyChar = &quot;]&quot;
            case &quot;?&quot;:
                keyChar = &quot;;&quot;    
            case &quot;?&quot;:
                keyChar = &quot;&apos;&quot;
            case &quot;?&quot;:
                keyChar = &quot;,&quot;
            case &quot;?&quot;:
                keyChar = &quot;.&quot;
            case &quot;.&quot;:
                keyChar = &quot;.&quot;                
            case 521:
                keyChar = &quot;о&quot;
        End Select
    Else
        Select Case oEvent.keyChar
            case &quot;?&quot;:
                keyChar = &quot;{&quot;
            case &quot;?&quot;:
                keyChar = &quot;}&quot;
            case &quot;?&quot;:
                keyChar = &quot;:&quot;    
            case &quot;?&quot;:
                keyChar = chr(34)
            case &quot;?&quot;:
                keyChar = &quot;&lt;&quot;
            case &quot;?&quot;:
                keyChar = &quot;&gt;&quot;
        End Select
    End If
    getLatinKeyCharByRus = keyChar    
End Function

Function getLatinKey(oEvent)
    dim keyChar
    keyChar = asc(0)
    If oEvent.keyCode &lt;&gt; 0 Then
        keyChar = getLatinKeyCharByCode(oEvent)
    Else
        keyChar = getLatinKeyCharByRus(oEvent)
    End If
    getLatinKey = keyChar
End Function

Function isControl(c)
	if len(c) = 0 then
		isControl = True
	else
		dim ac as integer : ac = asc(c)
		isControl = ((ac &gt;= 0 and ac &lt;= 31) or (ac = 127))
	end if
End Function

Function isPrintable(c)
	isPrintable = not isControl(c)
End Function

Sub restoreStatus &apos;restore original statusbar
	On Error Goto ErrorHandler
    dim oCurrentContorller : oCurrentContorller = getCurrentController()
   	dim oFrame : oFrame = oCurrentContorller.Frame
   	dim oLayout : oLayout = oFrame.LayoutManager
  	oLayout.destroyElement(&quot;private:resource/statusbar/statusbar&quot;)
   	oLayout.createElement(&quot;private:resource/statusbar/statusbar&quot;)
   	Exit Sub
ErrorHandler:
	MsgBox(&quot;restoreStatus() failed!&quot;)
End Sub

&apos; Unfortunately, does not work as expected
&apos; Statusbar of the currently active window is restored, because background windows
&apos; return the controller of the currently active window on getCurrentController
&apos; Thus the statusbar of active window is restored several times, and status bars
&apos; of background windows are not restored at all
Sub restoreStatusOfModels()
    dim vComponents
	dim hasUnoI
    vComponents = StarDesktop.getComponents()
    If vComponents.hasElements() Then
    	dim vEnumeration
    	vEnumeration = vComponents.createEnumeration()
    	Do While vEnumeration.hasMoreElements()
    		dim vComponent
    		vComponent = vEnumeration.nextElement()
			If APP() &lt;&gt; &quot;CALC&quot; Then
				If HasUnoInterfaces(vComponent, &quot;com.sun.star.text.XTextDocument&quot;) Then hasUnoI = True Else hasUnoI = False
			Else
				hasUnoI = True
			End If
    		If hasUnoI Then
				dim oController
				
    			oController = vComponent.getCurrentController()
	    		static oOldController as object
	    		If EqualUnoObjects(oController, oOldController) Then
	    		&apos;	MsgBox(&quot;controllers are the same&quot;)
	    		End If
	    		oOldController = oController
	    		
    			If not (oController is Nothing) Then
			    	dim oFrame
			    	oFrame = oController.getFrame()
			    	dim oLayout
			    	oLayout = oFrame.LayoutManager
			    	oLayout.destroyElement(&quot;private:resource/statusbar/statusbar&quot;)
				    oLayout.createElement(&quot;private:resource/statusbar/statusbar&quot;)
			   	End If
    		End If
    	Loop	
    End If
End Sub

Sub setRawStatus(rawText)
	dim oCurrentController as object
	oCurrentController = getCurrentController()
	If not (oCurrentController is Nothing) Then
	    oCurrentcontroller.StatusIndicator.Start(rawText, 0)
	End If
End Sub

Sub setStatus()
    setRawStatus(getModeName(MODE) &amp; &quot; | &quot; &amp; getMultiplier() &amp; &quot; | special: &quot; &amp; getSpecial() &amp; &quot; | &quot; &amp; &quot;modifier: &quot; &amp; getMovementModifier())
End Sub

&apos; Try to use statusbar to save state of window, allowing for multiple windows to support vibreoffice&apos;
&apos; Seemingly No such funciton is available to read the statusbar from the api?&apos;
Function getStatus() As String
    thisComponent.Currentcontroller.StatusIndicator
    &apos;setRawStatus(MODE &amp; &quot; | &quot; &amp; statusText &amp; &quot; | special: &quot; &amp; getSpecial() &amp; &quot; | &quot; &amp; &quot;modifier: &quot; &amp; getMovementModifier())
End Function

Sub setMode(m)
    MODE = m
    setStatus()
End Sub

&apos; Selects the current line and makes it the Visual base line for use with 
&apos; VISUAL_LINE mode.
Function formatVisualBase()
If APP() &lt;&gt; &quot;CALC&quot; Then
    dim oTextCursor
    oTextCursor = getTextCursor()
    VISUAL_BASE = getCursor().getPosition()

    &apos; Select the current line by moving cursor to start of the bellow line and 
    &apos; then back to the start of the current line.
    getCursor().gotoEndOfLine(False)
    If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
        getCursor().goRight(1, False)
    End If
    getCursor().goLeft(1, True)
    getCursor().gotoStartOfLine(True)
Else
	simulate_KeyPress_Char(&quot;HOME&quot;)
	simulate_KeyPress_Char(&quot;END&quot;,&quot;SHIFT&quot;)
End If
End Function

Function gotoMode(sMode)
    Select Case sMode
        Case M_NORMAL, M_DISABLED:
            setMode(sMode)
            setMovementModifier(&quot;&quot;)
		Case M_INSERT:
            setMode(sMode)
		Case M_VISUAL:
            setMode(sMode)
			If APP() &lt;&gt; &quot;CALC&quot; Then
				dim oTextCursor
				oTextCursor = getTextCursor()
				&apos; Deselect TextCursor
				If not (oTextCursor is Nothing) Then
					oTextCursor.gotoRange(oTextCursor.getStart(), False)
					&apos; Show TextCursor selection
					getCurrentController().Select(oTextCursor)
				End If
			End If
		Case M_VISUAL_LINE:
            setMode(sMode)
            formatVisualBase()
		Case Else:
			&apos; Should not happen
			setMode(M_BAD)
    End Select
End Function

Sub cursorPreReset(oTextCursor)
    oTextCursor.gotoRange(oTextCursor.getStart(), False)
    oTextCursor.goRight(1, False)
	oTextCursor.goLeft(1, True)
End Sub

Sub cursorReset(oTextCursor)
	cursorPreReset(oTextCursor)	
    getCurrentController().Select(oTextCursor) &apos; needed
End Sub

Sub searchAndSet(oTextCursor, sText, bIsBackwards)
	If APP() &lt;&gt; &quot;CALC&quot; Then
    dim oSearchDesc as object
    oSearchDesc = thisComponent.createSearchDescriptor()
    oSearchDesc.setSearchString(sText)
    oSearchDesc.SearchCaseSensitive = True
    oSearchDesc.SearchBackwards = bIsBackwards
    dim oStartRange	    
		If Not bIsBackwards Then
			oStartRange = oTextCursor.getEnd()
		Else
			oStartRange = oTextCursor.getStart()
		End If
    dim oFoundRange	    
    oFoundRange = thisComponent.findNext(oStartRange, oSearchDesc)	    
	If not (oFoundRange is Nothing) Then
		oTextCursor.gotoRange(oFoundRange, False)
		getCurrentController().Select(oTextCursor)
		setMode(M_VISUAL)
	End If
	Else
		simulate_KeyPress_Char(&quot;F&quot;,&quot;CTRL&quot;)
	End If
End Sub

&apos; swaps cursor start and end
&apos; have to resort to the crude string-based algorithm because of annotation chars
&apos; BUG minor bug: on swap will exclude annotation chars present on either end of selection
Sub swapCursorEnds(oTextCursor as object)
	dim s, oldLen
	s = oTextCursor.getString()
	oldLen = len(s)
	If oldLen = 0 Then Exit Sub
	oTextCursor.goRight(1, True)
	dim newLen : newLen = len(oTextCursor.getString())
	If newLen &gt; oldLen Then oTextCursor.goLeft(1, False)
	dim pureLen : pureLen = newLen - count(s, chr(10))
	dim t as string
	If newLen &gt;= oldLen Then
		oTextCursor.collapseToEnd()
		oTextCursor.goLeft(pureLen-1, True)
        do while oTextCursor.getString() &lt;&gt; s
        	t = oTextCursor.getString()
			oTextCursor.goLeft(1, True)
		Loop
	Else
		oTextCursor.collapseToStart()
		oTextCursor.goLeft(1, False) &apos;collapsing to start does not include starting character for some reason
        oTextCursor.goRight(pureLen, True)
        do while oTextCursor.getString() &lt;&gt; s
        	t = oTextCursor.getString()
			oTextCursor.goRight(1, True)
		Loop
	End If
End Sub

Function samePos(oPos1, oPos2)
    samePos = oPos1.X() = oPos2.X() And oPos1.Y() = oPos2.Y()
End Function

Function genString(sChar, iLen)
    dim sResult, i
    sResult = &quot;&quot;
    For i = 1 To iLen
        sResult = sResult &amp; sChar
    Next i
    genString = sResult
End Function

&apos; Counts number of character c in string s
Function count(s as string, c)
	dim cnt
	cnt = 0
	dim length
	length = len(s)
	dim i
	For i = 1 to length
		If asc(Mid(s,i,1)) = asc(c) Then cnt = cnt + 1
	Next
	count = cnt
End Function

&apos; Yanks selection to system clipboard.
&apos; If bDelete is true, will delete selection.
Sub yankSelection(bDelete)
    dim dispatcher As Object
    dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
    dispatcher.executeDispatch(getCurrentController().Frame, &quot;.uno:Copy&quot;, &quot;&quot;, 0, Array())

    If bDelete Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
			getTextCursor().setString(&quot;&quot;)
		Else
			simulate_KeyPress_Char(&quot;DELETE&quot;)
		End If
    End If
End Sub


Sub pasteSelection()
    dim oTextCursor, dispatcher As Object

    &apos; Deselect if in NORMAL mode to avoid overwriting the character underneath
    &apos; the cursor
    If MODE = M_NORMAL Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
        oTextCursor = getTextCursor()
        oTextCursor.gotoRange(oTextCursor.getStart(), False)
        getCurrentController().Select(oTextCursor)
		End If
    End If

    dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
    dispatcher.executeDispatch(getCurrentController().Frame(), &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
End Sub


&apos; -----------------------------------
&apos; Special Mode (for chained commands)
&apos; -----------------------------------
global SPECIAL_MODE As string
global SPECIAL_COUNT As integer

Sub setSpecial(specialName)
    SPECIAL_MODE = specialName

    If specialName = &quot;&quot; Then
        SPECIAL_COUNT = 0
    Else
        SPECIAL_COUNT = 2
    End If
End Sub

Function getSpecial()
    getSpecial = SPECIAL_MODE
End Function

Sub delaySpecialReset()
    SPECIAL_COUNT = SPECIAL_COUNT + 1
End Sub

Sub resetSpecial(Optional bForce)
    If IsMissing(bForce) Then bForce = False

    SPECIAL_COUNT = SPECIAL_COUNT - 1
    If SPECIAL_COUNT &lt;= 0 Or bForce Then
        setSpecial(&quot;&quot;)
    End If
End Sub


&apos; -----------------
&apos; Movement Modifier
&apos; -----------------
&apos;f,i,a
global MOVEMENT_MODIFIER As string

Sub setMovementModifier(modifierName)
    MOVEMENT_MODIFIER = modifierName
End Sub

Function getMovementModifier()
    getMovementModifier = MOVEMENT_MODIFIER
End Function


&apos; --------------------
&apos; Multiplier functions
&apos; --------------------
Sub _setMultiplier(n as integer)
    MULTIPLIER = n
End Sub

Sub resetMultiplier()
    _setMultiplier(0)
End Sub

Sub addToMultiplier(n as integer)
    dim sMultiplierStr as String
    dim iMultiplierInt as integer

    &apos; Max multiplier: 10000 (stop accepting additions after 1000)
    If MULTIPLIER &lt;= 1000 then
        sMultiplierStr = CStr(MULTIPLIER) &amp; CStr(n)
        _setMultiplier(CInt(sMultiplierStr))
    End If
End Sub

&apos; Should only be used if you need the raw value
Function getRawMultiplier()
    getRawMultiplier = MULTIPLIER
End Function

&apos; Same as getRawMultiplier, but defaults to 1 if it is unset (0)
Function getMultiplier()
    If MULTIPLIER = 0 Then
        getMultiplier = 1
    Else
        getMultiplier = MULTIPLIER
    End If
End Function


&apos; -------------
&apos; Key Handling
&apos; -------------
&apos; Buggy due to the same reason as restoreStatusOfModels() is
Sub addKeyHandlerToModels()
	dim hasUnoI
	If oXKeyHandler is nothing Then
		Exit Sub
	End If
	
    dim vComponents
    vComponents = StarDesktop.getComponents()
    If vComponents.hasElements() Then
    	dim vEnumeration
    	vEnumeration = vComponents.createEnumeration()
    	Do While vEnumeration.hasMoreElements()
    		dim vComponent
    		vComponent = vEnumeration.nextElement()
			If APP() &lt;&gt; &quot;CALC&quot; Then
				If HasUnoInterfaces(vComponent, &quot;com.sun.star.text.XTextDocument&quot;) Then hasUnoI = True Else hasUnoI = False
			Else
				hasUnoI = True
			End If
    		If hasUnoI Then
				dim oController
    			oController = vComponent.getCurrentController()
    			If not (oController is Nothing) Then
			    	oController().addKeyHandler(oXKeyHandler)
			   	End If
    		End If
    	Loop	
    End If
End Sub


&apos; Buggy due to the same reason as restoreStatusOfModels() is
Sub removeKeyHandlerFromModels()
	dim hasUnoI
    dim vComponents
    vComponents = StarDesktop.getComponents()
    If vComponents.hasElements() Then
    	dim vEnumeration
    	vEnumeration = vComponents.createEnumeration()
    	Do While vEnumeration.hasMoreElements()
    		dim vComponent
    		vComponent = vEnumeration.nextElement()
			If APP() &lt;&gt; &quot;CALC&quot; Then
				If HasUnoInterfaces(vComponent, &quot;com.sun.star.text.XTextDocument&quot;) Then hasUnoI = True Else hasUnoI = False
			Else
				hasUnoI = True
			End If
    		If hasUnoI Then
				dim oController
    			oController = vComponent.getCurrentController()
    			If not (oController is Nothing) Then
			    	oController().removeKeyHandler(oXKeyHandler)
			    End If
    		End If
    	Loop	
    End If
End Sub


Sub sStartXKeyHandler
	sStopXKeyHandler()
    oXKeyHandler = CreateUnoListener(&quot;KeyHandler_&quot;, &quot;com.sun.star.awt.XKeyHandler&quot;)
End Sub

Sub sStopXKeyHandler
End Sub

Sub KeyHandler_Disposing(oEvent)
End Sub


&apos; --------------------
&apos; Main Key Processing
&apos; --------------------
function KeyHandler_KeyPressed(oEvent) as boolean
    If oEvent.KeyCode = 1281 And oEvent.Modifiers = 1 Then
    	toggleVibreoffice()
    	KeyHandler_KeyPressed = True
    	Exit Function
    End If

    &apos; Exit if plugin is not enabled
    If MODE = M_DISABLED Then
        KeyHandler_KeyPressed = False
        Exit Function
    End If
    
    &apos; Have to resort to polling because subscribing to theGlobalEventBroadcaster causes crashes
    dim oFrame : oFrame = StarDesktop.getCurrentFrame()
    if not EqualUnoObjects(oFrame, oCurrentFrame) then
    	reinitVibreOffice()
    	oCurrentFrame = oFrame
    end if
    
	if oEvent.keyChar = &quot;=&quot; and oEvent.Modifiers &gt; 1 then
		MsgBox(logged2)
		logged2 = &quot;&quot;
		KeyHandler_KeyPressed = True
		Exit Function
	end if    
	
	if oEvent.keyChar = &quot;-&quot; and oEvent.Modifiers &gt; 1 then
		dim oCur : oCur = getTextCursor()
		dim s : s = oCur.getString()
		
		if len(s) = 0 then 
			s = &quot;&lt;&gt;&quot;
		elseif isControl(s) then 
			s = &quot;&lt;&quot; &amp; asc(s) &amp; &quot;&gt;&quot;
		end if
		
		s = s &amp; chr(13) &amp; TRAP_STATE
		
		MsgBox(s)
		KeyHandler_KeyPressed = True
		Exit Function
	end if	


	&apos;CHECK&apos;
	If APP() &lt;&gt; &quot;CALC&quot; Then
    &apos; Exit if TextCursor does not work (as in Annotations)
	Dim oTextCursor
    oTextCursor = getTextCursor()
    If oTextCursor Is Nothing Then
        KeyHandler_KeyPressed = False
        Exit Function
    End If
    End If

    dim bConsumeInput : bConsumeInput = True &apos; Block all inputs by default

        
    &apos; --------------------------
    &apos; Process global shortcuts, exit if matched (like ESC)
    If ProcessGlobalKey(oEvent) Then
        &apos; Pass
    &apos; If INSERT mode, allow all inputs
    ElseIf MODE = M_INSERT Then
		bConsumeInput = True
		dim c : c = oEvent.keyChar	
		
		if isPrintable(c) then
			logged2 = logged2 &amp; c
			&apos;TODO Revert if characters are still being swapped during input
			&apos;print_string(getTextCursor(), c)
			&apos;bConsumeInput = True
			bConsumeInput = False
		else
			logged2 = logged2 &amp; &quot;&lt;&quot; &amp; asc(c) &amp; &quot;&gt;&quot;
			bConsumeInput = False
		end if
    Else
    	dim bIsMultiplier, bIsModified, bIsControl, bIsSpecial
	    bIsMultiplier = False &apos; reset multiplier by default
	    bIsModified = oEvent.Modifiers &gt; 1 &apos; If Ctrl or Alt is held down. (Shift=1)
	    bIsControl = (oEvent.Modifiers = 2) or (oEvent.Modifiers = 8)
	    bIsSpecial = getSpecial() &lt;&gt; &quot;&quot;        	
	    &apos; If Change Mode
	    &apos; ElseIf MODE = M_NORMAL And Not bIsSpecial And getMovementModifier() = &quot;&quot; And ProcessModeKey(oEvent) Then
	    If ProcessModeKey(oEvent) Then
	        &apos; Pass
	
	    &apos; Replace Key
	    ElseIf getSpecial() = &quot;r&quot; And Not bIsModified Then
	        dim iLen
	        iLen = Len(getCursor().getString())
	        getCursor().setString(genString(oEvent.KeyChar, iLen))
	
	    &apos; Normal Key
	    ElseIf ProcessNormalKey(getLatinKey(oEvent), oEvent.Modifiers, oEvent) Then
	        &apos; Pass
	
	    &apos; Multiplier Key
	    ElseIf ProcessNumberKey(oEvent) Then
	        bIsMultiplier = True
	        delaySpecialReset()
	
	    &apos; If is modified but doesn&apos;t match a normal command, allow input
	    &apos;   (Useful for built-in shortcuts like Ctrl+a, Ctrl+s, Ctrl+w)
	    ElseIf bIsModified Then
	        &apos; Ctrl+a (select all) sets mode to VISUAL
	        If bIsControl And getLatinKey(oEvent) = &quot;a&quot; Then
	            gotoMode(M_VISUAL)
	        End If
	        bConsumeInput = False
	
	    &apos; Movement modifier here?
	    ElseIf ProcessMovementModifierKey(getLatinKey(oEvent)) Then
	        delaySpecialReset()
	
	    &apos; If standard movement key (in VISUAL mode) like arrow keys, home, end
	    ElseIf (MODE = M_VISUAL Or MODE = M_VISUAL_LINE) And ProcessStandardMovementKey(oEvent) Then
	        &apos; Pass
	
	    &apos; If bIsSpecial but nothing matched, return to normal mode
	    ElseIf bIsSpecial Then
	        gotoMode(M_NORMAL)
	
	    &apos; Allow non-letter keys if unmatched
	    &apos; TODO Use getLatinKey()
	    ElseIf asc(oEvent.KeyChar) = 0 Then
	        bConsumeInput = False
	    End If
	    &apos; --------------------------
	
	    &apos; Reset Special
	    resetSpecial()
	
	    &apos; Reset multiplier if last input was not number and not in special mode
	    If not bIsMultiplier and getSpecial() = &quot;&quot; and getMovementModifier() = &quot;&quot; Then
	        resetMultiplier()
	    End If
	    setStatus(getMultiplier())
	End If

    KeyHandler_KeyPressed = bConsumeInput
End Function

Function KeyHandler_KeyReleased(oEvent) As boolean
    &apos; Exit if plugin is not enabled
    If MODE = M_DISABLED Then
        KeyHandler_KeyReleased = False
        Exit Function
    End If
    
    If asc(oEvent.KeyChar) = 0 Then
        KeyHandler_KeyReleased = False
    Else
        dim iModifiers as integer
        iModifiers = oEvent.modifiers
        dim iKeyCode as integer
        iKeyCode = oEvent.keyCode
	    &apos; Allow Ctrl+c for Copy, so don&apos;t change cursor
        If iKeyCode = 514 And (iModifiers = 2 Or iModifiers = 8) Then
        &apos; Needed to make cursor always select 1 character in NORMAL mode
        &apos; Constrict to movement keys only?
        ElseIf MODE = M_NORMAL Then
	        &apos; Show terminal-like cursor
			dim oTextCursor
	        oTextCursor = getTextCursor()
	        If not (oTextCursor Is Nothing) Then
	            &apos; Do nothing        
	           cursorReset(oTextCursor)
	        End If
        End If

        KeyHandler_KeyReleased = (MODE = M_NORMAL) &apos;cancel KeyReleased
    End If
End Function


&apos; ----------------
&apos; Processing Keys
&apos; ----------------
Function ProcessGlobalKey(oEvent)
    dim bMatched, bIsControl
    bMatched = False
    bIsControl = (oEvent.Modifiers = 2) or (oEvent.Modifiers = 8)

    &apos; keycode can be viewed here: http://api.libreoffice.org/docs/idl/ref/namespacecom_1_1sun_1_1star_1_1awt_1_1Key.html
    &apos; PRESSED ESCAPE (or ctrl+[)
    If oEvent.KeyCode = 1281 Or (oEvent.KeyCode = 1315 And bIsControl) Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			If getTextCursor() is Nothing Then
				bMatched = False
			Else
				&apos; Move cursor back if was in INSERT (but stay on same line)
				If MODE &lt;&gt; M_NORMAL And Not getCursor().isAtStartOfLine() Then
					getCursor().goLeft(1, False)
				End If
				bMatched = True
			End If
		Else
			If (MODE = M_VISUAL Or MODE = M_VISUAL_LINE) Then
			simulate_KeyPress_Char(&quot;ESCAPE&quot;)
			simulate_KeyPress_Char(&quot;DOWN&quot;)
			simulate_KeyPress_Char(&quot;UP&quot;)
			ElseIf (MODE = M_INSERT) Then
			&apos; Prevents cell entries from being undone&apos;
			simulate_KeyPress_Char(&quot;DOWN&quot;)
			simulate_KeyPress_Char(&quot;UP&quot;)
			
			End If
        	bMatched = True
        End If

        resetSpecial(True)
		resetMultiplier()
        gotoMode(M_NORMAL)
    Else
        bMatched = False
    End If
    ProcessGlobalKey = bMatched
End Function


Function ProcessStandardMovementKey(oEvent)
    dim c, bMatched
    c = oEvent.KeyCode
	TEST = c

    bMatched = True

    If (MODE &lt;&gt; M_VISUAL And MODE &lt;&gt; M_VISUAL_LINE)Then
        bMatched = False
        &apos;Pass
    ElseIf c = 1024 Then
        ProcessMovementKey(&quot;j&quot;, True)
    ElseIf c = 1025 Then
        ProcessMovementKey(&quot;k&quot;, True)
    ElseIf c = 1026 Then
        ProcessMovementKey(&quot;h&quot;, True)
    ElseIf c = 1027 Then
        ProcessMovementKey(&quot;l&quot;, True)
    ElseIf c = 1028 Then
        ProcessMovementKey(&quot;^&quot;, True)
    ElseIf c = &quot;0&quot;   and getRawMultiplier() = 0 Then
    &apos;and getRawMultiplier() = 0
    	&apos; Only if this entry is not part of the multiplier
			ProcessMovementKey(&quot;0&quot;, True) &apos; key for zero (0)

     ElseIf c = 1029 Then
        ProcessMovementKey(&quot;$&quot;, True)
    Else
        bMatched = False
    End If

    ProcessStandardMovementKey = bMatched
End Function


Function ProcessNumberKey(oEvent)
    dim c
    c = CStr(oEvent.KeyChar)

	&apos; Don&apos;t treat number keys as multiplier-related 
	&apos; if we are in modified movement mode (like f,t)
	&apos; Otherwise will not be able to search for numbers with f or t at all
    If getMovementModifier() = &quot;&quot; and c &gt;= &quot;0&quot; and c &lt;= &quot;9&quot; Then
        addToMultiplier(CInt(c))
        ProcessNumberKey = True
    Else
        ProcessNumberKey = False
    End If
End Function


Function ProcessModeKey(oEvent)
	dim keyChar
    dim bIsModified
    bIsModified = oEvent.Modifiers &gt; 1 &apos; If Ctrl or Alt is held down. (Shift=1)
    &apos; Don&apos;t change modes in these circumstances
    If MODE &lt;&gt; M_NORMAL Or bIsModified Or getSpecial &lt;&gt; &quot;&quot; Or getMovementModifier() &lt;&gt; &quot;&quot; Then
        ProcessModeKey = False
        Exit Function
    End If

    &apos; Mode matching
    dim bMatched, oTextCursor
    bMatched = True
    keyChar = getLatinKey(oEvent)
	oTextCursor = getTextCursor()
	TEST = oEvent.KeyChar
    Select Case oEvent.KeyChar
        &apos; Insert modes
        Case &quot;i&quot;, &quot;ш&quot;, &quot;a&quot;, &quot;ф&quot;, &quot;I&quot;, &quot;Ш&quot;, &quot;A&quot;, &quot;Ф&quot;, &quot;o&quot;, &quot;щ&quot;, &quot;O&quot;, &quot;Щ&quot;:
			If APP() &lt;&gt; &quot;CALC&quot; Then
				If oEvent.KeyChar = &quot;ф&quot; Or &quot;a&quot; And NOT oTextCursor.isEndOfParagraph() Then getCursor().goRight(1, False)
				If oEvent.KeyChar = &quot;I&quot; Or oEvent.KeyChar = &quot;Ш&quot; Then ProcessMovementKey(&quot;^&quot;)
				If oEvent.KeyChar = &quot;A&quot; Or oEvent.KeyChar = &quot;Ф&quot; Then ProcessMovementKey(&quot;$&quot;)
			Else
				If oEvent.KeyChar = &quot;I&quot; Or oEvent.KeyChar = &quot;Ш&quot; Then 
					simulate_KeyPress_Char(&quot;F2&quot;)
					simulate_KeyPress_Char(&quot;HOME&quot;)
				End If
				If oEvent.KeyChar = &quot;a&quot; Or oEvent.KeyChar = &quot;ф&quot; Then simulate_KeyPress_Char(&quot;F2&quot;)
				If oEvent.KeyChar = &quot;A&quot; Or oEvent.KeyChar = &quot;Ф&quot; Then simulate_KeyPress_Char(&quot;F2&quot;) 
			End If

            If KeyChar = &quot;o&quot; Or oEvent.KeyChar = &quot;щ&quot; Then
				If APP() &lt;&gt; &quot;CALC&quot; Then
				    ProcessMovementKey(&quot;$&quot;)
                	ProcessMovementKey(&quot;l&quot;)
					getCursor().setString(chr(13))
					If Not getCursor().isAtStartOfLine() Then
						getCursor().setString(chr(13) &amp; chr(13))
						ProcessMovementKey(&quot;l&quot;)
					End If
				Else
					insertRow(1)
					ProcessMovementKey(&quot;j&quot;)
				End If
            End If

            If KeyChar = &quot;O&quot; Or oEvent.KeyChar = &quot;Щ&quot; Then
				If APP() &lt;&gt; &quot;CALC&quot; Then
				    ProcessMovementKey(&quot;^&quot;)
					getCursor().setString(chr(13))
					If Not getCursor().isAtStartOfLine() Then
						ProcessMovementKey(&quot;h&quot;)
						getCursor().setString(chr(13))
						ProcessMovementKey(&quot;l&quot;)
					End If
				Else
					insertRow(0)
				End If
            End If

            gotoMode(M_INSERT)
        Case &quot;v&quot;, &quot;м&quot;:
            gotoMode(M_VISUAL)
        Case &quot;V&quot;, &quot;М&quot;:
            gotoMode(M_VISUAL_LINE)
        Case Else:
            bMatched = False
    End Select
    ProcessModeKey = bMatched
End Function


Function ProcessNormalKey(keyChar, modifiers, optional oEvent)
    dim i, bMatched, bMatchedMovement, bIsVisual, iIterations, bIsControl, sSpecial
	dim oTextCursor
    bIsControl = (modifiers = 2) or (modifiers = 8)
    bIsVisual = (MODE = M_VISUAL Or MODE = M_VISUAL_LINE) &apos; is this hardcoding bad? what about visual block?

	If bIsVisual and keyChar = &quot;o&quot; Then
		oTextCursor = getTextCursor()
		swapCursorEnds(oTextCursor)
		getCurrentController().select(oTextCursor)
        ProcessNormalKey = True
        Exit Function		
	End If

    &apos; ----------------------
    &apos; 1. Check Movement Key
    &apos; ----------------------
    iIterations = getMultiplier()
    sSpecial = getSpecial()
    bMatched = False
    bMatchedMovement = False
    &apos; starting from 0 adds one extra, unneeded movement
    &apos; FIXME axf Currently, say, &lt;num&gt;f&lt;char&gt; and d&lt;num&gt;f&lt;char&gt; commands differ if cursor is on &lt;char&gt;
    For i = 1 To iIterations 
        &apos; Movement Key
        &apos; axf Passing oEvent to make actual key char available for search
        bMatchedMovement = ProcessMovementKey(keyChar, bIsVisual, modifiers, oEvent)
        bMatched = bMatched or bMatchedMovement
    Next i

    &apos; If Special: d/c + movement
    If bMatched And (sSpecial = &quot;d&quot; Or sSpecial = &quot;c&quot; Or sSpecial = &quot;y&quot;) Then
        yankSelection((sSpecial &lt;&gt; &quot;y&quot;))
    End If    

    &apos; Reset Movement Modifier
    setMovementModifier(&quot;&quot;)

    &apos; Exit already if movement key was matched
    If bMatched Then
        &apos; If Special: d/c : change mode
        If getSpecial() = &quot;d&quot; Or getSpecial() = &quot;y&quot; Then gotoMode(M_NORMAL)
        If getSpecial() = &quot;c&quot; Then gotoMode(M_INSERT)

        ProcessNormalKey = True
        Exit Function
    End If


    &apos; --------------------
    &apos; 2. Undo/Redo
    &apos; --------------------
    If keyChar = &quot;u&quot; Or (bIsControl And keyChar = &quot;r&quot;) Then
        dim mode
        mode = 0
        If keyChar = &quot;u&quot; Then
            mode = 1
        End If

        For i = 1 To iIterations
            Undo(mode)
        Next i

        ProcessNormalKey = True
        Exit Function
    End If


    &apos; --------------------
    &apos; 3. Paste
    &apos;   Note: in vim, paste will result in cursor being over the last character
    &apos;   of the pasted content. Here, the cursor will be the next character
    &apos;   after that. Fix?
    &apos; --------------------
    If keyChar = &quot;p&quot; or keyChar = &quot;P&quot; Then
        &apos; Move cursor right if &quot;p&quot; to paste after cursor
		If APP() &lt;&gt; &quot;CALC&quot; Then
        Redim oTextCursor
        oTextCursor = getTextCursor()
        &apos; Move cursor right if &quot;p&quot; to paste after cursor
        If keyChar = &quot;p&quot; And NOT oTextCursor().isEndOfParagraph() Then
            ProcessMovementKey(&quot;l&quot;, False)
        End If
		End If

        For i = 1 To iIterations
            pasteSelection()
        Next i

        ProcessNormalKey = True
        Exit Function
    End If
    
	&apos;CHECK&apos;
    &apos; search
    &apos; HACK Remapping to make compatible with Russian keyboard layout
    If keyChar = &quot;.&quot; Then 
    	keyChar = &quot;/&quot; 
    ElseIf keyChar = &quot;&gt;&quot; Then
    	keyChar = &quot;?&quot;
    End If
    
    If keyChar = &quot;/&quot; or keyChar = &quot;?&quot; Then
    	dim sDir
    	If keyChar = &quot;/&quot; Then
    		sDir = &quot;forward&quot;
    	Else
    		sDir = &quot;backward&quot;
    	End If
    	sDir = &quot;Search &quot; &amp; sDir
		If APP() &lt;&gt; &quot;CALC&quot; Then
    	dim sInput
    	sInput = InputBox(sDir, sDir)
    	If sInput &lt;&gt; &quot;&quot; Then
    		dim bIsBackwards
	 	    bIsBackwards = (keyChar = &quot;?&quot;)
		    searchAndSet(getTextCursor(), sInput, bIsBackwards)
			LAST_SEARCH = sInput
	   		ProcessNormalKey = True
	        Exit Function	
	     End If	
		 Else
			 simulate_KeyPress_Char(&quot;F&quot;,&quot;CTRL&quot;)
		 End If
    End If

    &apos; --------------------
    &apos; 4. Check Special/Delete Key
    &apos; --------------------

    &apos; There are no special/delete keys with modifier keys, so exit early
    If modifiers &gt; 1 Then
        ProcessNormalKey = False
        Exit Function
    End If

    &apos; Only &apos;x&apos; or Special (dd, cc) can be done more than once
    If keyChar &lt;&gt; &quot;x&quot; And keyChar &lt;&gt; &quot;X&quot; And getSpecial() = &quot;&quot; Then
        iIterations = 1
    End If
    For i = 1 To iIterations
        dim bMatchedSpecial

        &apos; Special/Delete Key
        bMatchedSpecial = ProcessSpecialKey(keyChar)

        bMatched = bMatched or bMatchedSpecial
    Next i


    ProcessNormalKey = bMatched
End Function


&apos; Function for both undo and redo
Sub Undo(bUndo)
    On Error Goto ErrorHandler

    If bUndo Then
        thisComponent.getUndoManager().undo()
    Else
        thisComponent.getUndoManager().redo()
    End If
    Exit Sub

    &apos; Ignore errors from no more undos/redos in stack
ErrorHandler:
    Resume Next
End Sub


Function ProcessSpecialKey(keyChar)
    dim oCursor, oTextCursor, bMatched, bIsSpecial, bIsDelete
    bMatched = True
    bIsSpecial = getSpecial() &lt;&gt; &quot;&quot;


    If keyChar = &quot;d&quot; Or keyChar = &quot;c&quot; Or keyChar = &quot;s&quot; Or keyChar = &quot;y&quot; Then
        bIsDelete = (keyChar &lt;&gt; &quot;y&quot;)

        &apos; Special Cases: &apos;dd&apos; and &apos;cc&apos;
        If bIsSpecial Then
            dim bIsSpecialCase
            bIsSpecialCase = (keyChar = &quot;d&quot; And getSpecial() = &quot;d&quot;) Or (keyChar = &quot;c&quot; And getSpecial() = &quot;c&quot;)

            If bIsSpecialCase Then


				If APP() &lt;&gt; &quot;CALC&quot; Then
					 &apos;ProcessMovementKey(&quot;^&quot;, False)
                     &apos;ProcessMovementKey(&quot;j&quot;, True)
            	&apos; A bit hacky, but works
					oCursor = getCursor()
					oCursor.gotoStartOfLine(False)
					oCursor.gotoEndOfLine(True)                

					oTextCursor = getTextCursor()
					&apos;oTextCursor.goRight(1, True)
					getCurrentController().Select(oTextCursor)
					yankSelection(bIsDelete)
				Else
					yankSelection(bIsDelete)
					removeRow()
				End If
                
            Elseif (keyChar = &quot;y&quot; And getSpecial() = &quot;y&quot;) Then
            	yankSelection(False)
            Else
                bMatched = False
            End If

            &apos; Go to INSERT mode after &apos;cc&apos;, otherwise NORMAL
            If bIsSpecialCase And keyChar = &quot;c&quot; Then
                gotoMode(M_INSERT)
            Else
                gotoMode(M_NORMAL)
            End If


        &apos; visual mode: delete selection
        ElseIf MODE = M_VISUAL Or MODE = M_VISUAL_LINE Then
			If APP() &lt;&gt; &quot;CALC&quot; Then
				oTextCursor = getTextCursor()
				getCurrentController().Select(oTextCursor)
			End If

            yankSelection(bIsDelete)

            If keyChar = &quot;c&quot; Or keyChar = &quot;s&quot; Then gotoMode(M_INSERT)
            If keyChar = &quot;d&quot; Or keyChar = &quot;y&quot; Then gotoMode(M_NORMAL)


        &apos; Enter Special mode: &apos;d&apos;, &apos;c&apos;, or &apos;y&apos; (&apos;s&apos; =&gt; &apos;cl&apos;)
        ElseIf MODE = M_NORMAL Then
				&apos; &apos;s&apos; =&gt; &apos;cl&apos;
				If keyChar = &quot;s&quot; Then
					If APP() &lt;&gt; &quot;CALC&quot; Then
						setSpecial(&quot;c&quot;)
						gotoMode(M_VISUAL)
						ProcessMovementKey(&quot;l&quot;, True)
						yankSelection(True)
						gotoMode(M_INSERT)	
					Else
						setSpecial(&quot;c&quot;)
						gotoMode(M_VISUAL)		
						yankSelection(True)
						simulate_KeyPress_Char(&quot;DELETE&quot;)	
						gotoMode(M_INSERT)	
					End If
				Else
					setSpecial(keyChar)
					gotoMode(M_VISUAL)
				End If

        End If

    &apos; If is &apos;r&apos; for replace
    ElseIf keyChar = &quot;r&quot; Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
			setSpecial(&quot;r&quot;)
		End If
	&apos; gg to go to beginning of text
	ElseIf keyChar = &quot;g&quot; Then
		If bIsSpecial Then
			If getSpecial() = &quot;g&quot; Then
			dim bExpand
			If APP() &lt;&gt; &quot;CALC&quot; Then
                &apos; If cursor is to left of current visual selection then select 
                &apos; from right end of the selection to the start of file.
                &apos; If cursor is to right of current visual selection then select 
                &apos; from left end of the selection to the start of file.
                If MODE = M_VISUAL Then
                    dim oldPos
                    oldPos = getCursor().getPosition()
                    getCursor().gotoRange(getCursor().getStart(), True)
                    If NOT samePos(getCursor().getPosition(), oldPos) Then
                        getCursor().gotoRange(getCursor().getEnd(), False)
                    End If

                &apos; If in VISUAL_LINE mode and cursor is bellow the Visual base 
                &apos; line then move it to the Visual base line, reformat the 
                &apos; Visual base line, and move cursor to start of file.
                ElseIf MODE = M_VISUAL_LINE Then
                    Do Until getCursor().getPosition().Y() &lt;= VISUAL_BASE.Y()
                        getCursor().goUp(1, False)
                    Loop
                    If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                        formatVisualBase()
                    End If
                End If

                bExpand = MODE = M_VISUAL Or MODE = M_VISUAL_LINE
                getCursor().gotoStart(bExpand)
			Else
                bExpand = MODE = M_VISUAL Or MODE = M_VISUAL_LINE
				If bExpand Then simulate_KeyPress_Char(&quot;UP&quot;, &quot;SHIFT&quot;, &quot;CTRL&quot;) Else simulate_KeyPress_Char(&quot;UP&quot;, &quot;CTRL&quot;)
			End If
			End If
		ElseIf MODE = M_NORMAL Or MODE = M_VISUAL Or MODE = M_VISUAL_LINE Then
			setSpecial(&quot;g&quot;)
		End If
			
		
    &apos; Otherwise, ignore if bIsSpecial
    ElseIf bIsSpecial Then
        bMatched = False

    ElseIf keyChar = &quot;x&quot; Or keyChar = &quot;X&quot; Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
			oTextCursor = getTextCursor()
			If keyChar = &quot;X&quot; And MODE &lt;&gt; M_VISUAL And MODE &lt;&gt; M_VISUAL_LINE Then
				oTextCursor.collapseToStart()
				oTextCursor.goLeft(1, True)
			End If
			getCurrentController().Select(oTextCursor)
			yankSelection(True)

			&apos; Reset Cursor
			cursorReset(oTextCursor)
		Else
			yankSelection(True)
			simulate_KeyPress_Char(&quot;DELETE&quot;)
		End If

        &apos; Goto NORMAL mode (in the case of VISUAL mode)
        gotoMode(M_NORMAL)

    ElseIf keyChar = &quot;D&quot; Or keyChar = &quot;C&quot; Then
        If MODE = M_VISUAL Or MODE = M_VISUAL_LINE Then
            ProcessMovementKey(&quot;^&quot;, False)
            ProcessMovementKey(&quot;$&quot;, True)
            ProcessMovementKey(&quot;l&quot;, True)
        Else
            &apos; Deselect
			If APP() &lt;&gt; &quot;CALC&quot; Then
				oTextCursor = getTextCursor()
				oTextCursor.gotoRange(oTextCursor.getStart(), False)
				getCurrentController().Select(oTextCursor)
			End If
            ProcessMovementKey(&quot;$&quot;, True)
        End If

        yankSelection(True)

        If keyChar = &quot;D&quot; Then
            gotoMode(M_NORMAL)
        ElseIf keyChar = &quot;C&quot; Then
            gotoMode(M_INSERT)
        End IF

    &apos; S only valid in NORMAL mode
    ElseIf keyChar = &quot;S&quot; And MODE = M_NORMAL Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
			ProcessMovementKey(&quot;^&quot;, False)
			ProcessMovementKey(&quot;$&quot;, True)
			yankSelection(True)
			gotoMode(M_INSERT)
		End If

    Else
        bMatched = False
    End If

    ProcessSpecialKey = bMatched
End Function


Function ProcessMovementModifierKey(keyChar)
    dim bMatched

    bMatched = True
    Select Case keyChar
        Case &quot;f&quot;, &quot;t&quot;, &quot;F&quot;, &quot;T&quot;, &quot;i&quot;, &quot;a&quot;:
            setMovementModifier(keyChar)
        Case Else:
            bMatched = False
    End Select

    ProcessMovementModifierKey = bMatched
End Function


Function ProcessSearchKey(oTextCursor, searchType, keyChar, bExpand)
    &apos;-----------
    &apos; Searching
    &apos;-----------
    dim bMatched, oSearchDesc, oFoundRange, bIsBackwards, oStartRange
    bMatched = True
	If APP() &lt;&gt; &quot;CALC&quot; Then
		bIsBackwards = (searchType = &quot;F&quot; Or searchType = &quot;T&quot;)

		If Not bIsBackwards Then
			&apos; VISUAL mode will goRight AFTER the selection
			If MODE &lt;&gt; M_VISUAL And MODE &lt;&gt; M_VISUAL_LINE Then
				&apos; Start searching from next character
				oTextCursor.goRight(1, bExpand)
			End If

			oStartRange = oTextCursor.getEnd()
			&apos; Go back one
			oTextCursor.goLeft(1, bExpand)
		Else
			oStartRange = oTextCursor.getStart()
		End If

		oSearchDesc = thisComponent.createSearchDescriptor()
		oSearchDesc.setSearchString(keyChar)
		oSearchDesc.SearchCaseSensitive = True
		oSearchDesc.SearchBackwards = bIsBackwards

		oFoundRange = thisComponent.findNext( oStartRange, oSearchDesc )

		If not IsNull(oFoundRange) Then
			dim oText, foundPos, curPos, bSearching
			oText = oTextCursor.getText()
			foundPos = oFoundRange.getStart()

			&apos; Unfortunately, we must go go to this &quot;found&quot; position one character at
			&apos; a time because I have yet to find a way to consistently move the
			&apos; Start range of the text cursor and leave the End range intact.
			If bIsBackwards Then
				curPos = oTextCursor.getEnd()
			Else
				curPos = oTextCursor.getStart()
			End If
			do until oText.compareRegionStarts(foundPos, curPos) = 0
				If bIsBackwards Then
					bSearching = oTextCursor.goLeft(1, bExpand)
					curPos = oTextCursor.getStart()
				Else
					bSearching = oTextCursor.goRight(1, bExpand)
					curPos = oTextCursor.getEnd()
				End If

				&apos; Prevent infinite if unable to find, but shouldn&apos;t ever happen (?)
				If Not bSearching Then
					bMatched = False
					Exit Do
				End If
			Loop

			If searchType = &quot;t&quot; Then
				oTextCursor.goLeft(1, bExpand)
			ElseIf searchType = &quot;T&quot; Then
				oTextCursor.goRight(1, bExpand)
			End If

		Else
			bMatched = False
		End If

		&apos; If matched, then we want to select PAST the character
		&apos; Else, this will counteract some weirdness. hack either way
		If Not bIsBackwards And (MODE = M_VISUAL Or MODE = M_VISUAL_LINE) Then
			oTextCursor.goRight(1, bExpand)
		End If
	Else
    bMatched = False
	End If

    ProcessSearchKey = bMatched

End Function


Function ProcessInnerKey(oTextCursor, movementModifier, keyChar, bExpand)
    dim bMatched, searchType1, searchType2, search1, search2

	If APP() &lt;&gt; &quot;CALC&quot; Then
		&apos; Setting searchType
		If movementModifier = &quot;i&quot; Then
			searchType1 = &quot;T&quot; : searchType2 = &quot;t&quot;
		ElseIf movementModifier = &quot;a&quot; Then
			searchType1 = &quot;F&quot; : searchType2 = &quot;f&quot;
		Else &apos; Shouldn&apos;t happen
			ProcessInnerKey = False
			Exit Function
		End If

		Select Case keyChar
			Case &quot;(&quot;, &quot;)&quot;:
				search1 = &quot;(&quot; : search2 = &quot;)&quot;
			Case &quot;{&quot;, &quot;}&quot;:
				search1 = &quot;{&quot; : search2 = &quot;}&quot;
			Case &quot;[&quot;, &quot;]&quot;:
				search1 = &quot;[&quot; : search2 = &quot;}&quot;
			Case &quot;&lt;&quot;, &quot;&gt;&quot;:
				search1 = &quot;&lt;&quot; : search2 = &quot;&gt;&quot;
			Case &quot;t&quot;:
				search1 = &quot;&gt;&quot; : search2 = &quot;&lt;&quot;
			Case &quot;&apos;&quot;:
				search1 = &quot;&apos;&quot; : search2 = &quot;&apos;&quot;
			Case &quot;&quot;&quot;&quot;:
				&apos; Matches &quot;smart&quot; quotes, which is default in libreoffice
				search1 = &quot;?&quot; : search2 = &quot;?&quot;
			Case Else:
				search1 = keyChar : search2 = keyChar
		End Select
		
			dim bMatched1, bMatched2
			bMatched1 = ProcessSearchKey(oTextCursor, searchType1, search1, False)
			bMatched2 = ProcessSearchKey(oTextCursor, searchType2, search2, True)
			&apos; Temp hack - need to search 2nd time to make da&lt;char&gt; work correctly
			If (search1 = search2) and (searchType2 = &quot;f&quot;) and bMatched1 Then
				bMatched2 = ProcessSearchKey(oTextCursor, searchType2, search2, True)
			End If
			bMatched = (bMatched1 And bMatched2)
	Else
		bMatched = False
	End If

    ProcessInnerKey = bMatched
End Function


&apos; -----------------------
&apos; Main Movement Function
&apos; -----------------------
&apos;   Default: bExpand = False, keyModifiers = 0
&apos;   axf Need to pass oEvent to make in available to called functions (i.e. search)
Function ProcessMovementKey(keyChar, Optional bExpand, Optional keyModifiers, Optional oEvent)
    dim oTextCursor, bSetCursor, bMatched
    &apos;If APP() &lt;&gt; &quot;CALC&quot; Then
    	oTextCursor = getTextCursor()
    &apos;End If
    bMatched = True
    If IsMissing(bExpand) Then bExpand = False
    If IsMissing(keyModifiers) Then keyModifiers = 0


    &apos; Check for modified keys (Ctrl, Alt, not Shift)
    If keyModifiers &gt; 1 Then
        dim bIsControl
        bIsControl = (keyModifiers = 2) or (keyModifiers = 8)

        &apos; Ctrl+d and Ctrl+u
        If bIsControl and keyChar = &quot;d&quot; Then
			If APP() &lt;&gt; &quot;CALC&quot; Then
				getCursor().ScreenDown(bExpand)
			Else
				If bExpand Then simulate_KeyPress_Char(&quot;PAGEDOWN&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;PAGEDOWN&quot;)
			End If
        ElseIf bIsControl and keyChar = &quot;u&quot; Then
			If APP() &lt;&gt; &quot;CALC&quot; Then
				getCursor().ScreenUp(bExpand)
			Else
				If bExpand Then simulate_KeyPress_Char(&quot;PAGEUP&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;PAGEUP&quot;)
			End If
        Else
            bMatched = False
        End If

        ProcessMovementKey = bMatched
        Exit Function
    End If

    &apos; Set global cursor to oTextCursor&apos;s new position if moved
    bSetCursor = True


    &apos; ------------------
    &apos; Movement matching
    &apos; ------------------

    &apos; ---------------------------------
    &apos; Special Case: Modified movements
	If getMovementModifier() &lt;&gt; &quot;&quot; Then
		Select Case getMovementModifier()
			&apos; f,F,t,T searching
		Case &quot;f&quot;, &quot;t&quot;, &quot;F&quot;, &quot;T&quot;:
		&apos;If APP() &lt;&gt; &quot;CALC&quot; Then
			bMatched  = ProcessSearchKey(oTextCursor, getMovementModifier(), keyChar, bExpand)
                LAST_SEARCH = oEvent.keyChar
		&apos;End If
		Case &quot;i&quot;, &quot;a&quot;:
			bMatched = ProcessInnerKey(oTextCursor, getMovementModifier(), keyChar, bExpand)

		Case Else:
			bSetCursor = False
			bMatched = False
		End Select

		If Not bMatched Then
			bSetCursor = False
		End If
	&apos; ---------------------------------

    &apos; Search repetition
    ElseIf keyChar = &quot;n&quot; or keyChar = &quot;N&quot; Then
        If keyChar = &quot;n&quot; Then
            &apos; MsgBox(&quot;n: &quot; &amp; LAST_SEARCH)
            &apos; bMatched  = ProcessSearchKey(oTextCursor, &quot;f&quot;, LAST_SEARCH_CHAR, bExpand)
            searchAndSet(getTextCursor(), LAST_SEARCH, False) 
        ElseIf keyChar = &quot;N&quot; Then
            &apos; MsgBox(&quot;N: &quot; &amp; LAST_SEARCH)
            &apos; bMatched  = ProcessSearchKey(oTextCursor, &quot;F&quot;, LAST_SEARCH_CHAR, bExpand) 
			searchAndSet(getTextCursor(), LAST_SEARCH, True)
        End If
        bSetCursor = False

    &apos; Basic movement
    ElseIf keyChar = &quot;l&quot; or keyChar = &quot;д&quot; Then
    	 If APP() = &quot;CALC&quot; Then
	       	&apos;Print &quot;This is Calc&quot;
			If bExpand Then simulate_KeyPress_Char(&quot;RIGHT&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;RIGHT&quot;)
        Else
        oTextCursor.goRight(1, bExpand)
        End If

    ElseIf keyChar = &quot;h&quot; or keyChar = &quot;р&quot; Then
    	 If APP() = &quot;CALC&quot; Then
	       	&apos;Print &quot;This is Calc&quot;
			If bExpand Then simulate_KeyPress_Char(&quot;LEFT&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;LEFT&quot;)
        Else
        oTextCursor.goLeft(1, bExpand)
        End If

    &apos; oTextCursor.goUp and oTextCursor.goDown SHOULD work, but doesn&apos;t (I dont know why).
    &apos; So this is a weird hack
    ElseIf keyChar = &quot;k&quot; or keyChar = &quot;л&quot; Then
        &apos;oTextCursor.goUp(1, False)
        If APP() = &quot;CALC&quot; Then
	       	&apos;Print &quot;This is Calc&quot;
			If bExpand Then simulate_KeyPress_Char(&quot;UP&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;UP&quot;)
        Else
        If MODE = M_VISUAL_LINE Then
            &apos; This variable represents the line that the user last selected.
            dim lastSelected

            &apos; If cursor is already on or above the Visual base line.
            If getCursor().getPosition().Y() &lt;= VISUAL_BASE.Y() Then
                lastSelected = getCursor().getPosition().Y()
                &apos; If on Visual base line then format it for selecting above 
                &apos; lines.
                If VISUAL_BASE.Y() = getCursor().getPosition().Y() Then
                    getCursor().gotoEndOfLine(False)
                    &apos; Make sure that cursor is on the start of the line bellow 
                    &apos; the Visual base line. This is needed to make sure the 
                    &apos; new line character will be selected.
                    If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                        getCursor().goRight(1, False)
                    End If
                End If

                &apos; Move cursor to start of the line above last selected line.
                Do Until getCursor().getPosition().Y() &lt; lastSelected
                    If NOT getCursor().goUp(1, bExpand) Then
                        Exit Do
                    End If
                Loop
                getCursor().gotoStartOfLine(bExpand)

            &apos; If cursor is already bellow the Visual base line.
            ElseIf getCursor().getPosition().Y() &gt; VISUAL_BASE.Y() Then
                &apos; Cursor will be under the last selected line so it needs to 
                &apos; be moved up before setting lastSelected.
                getCursor().goUp(1, bExpand)
                lastSelected = getCursor().getPosition().Y()
                &apos; Move cursor up another line to deselect the last selected
                &apos; line.
                getCursor().goUp(1, bExpand)

                &apos; For the case when the last selected line was the line bellow 
                &apos; the Visual base line, simply reformat the Visual base line.
                If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                    formatVisualBase()

                Else
                    &apos; Make sure that the current line is fully selected.
                    getCursor().gotoEndOfLine(bExpand)

                    &apos; Make sure cursor is at the start of the line we 
                    &apos; deselected. It needs to always be bellow the user&apos;s 
                    &apos; selection when under the Visual base line.
                    If getCursor().getPosition().Y() &lt; lastSelected Then
                        getCursor().goRight(1, bExpand)
                    End If
                End If

            End If

        Else
        &apos; oTextCursor.goUp and oTextCursor.goDown SHOULD work, but doesn&apos;t (I dont know why).
        &apos; So this is a weird hack
            &apos;oTextCursor.goUp(1, False)
            getCursor().goUp(1, bExpand)
        End If
        bSetCursor = False
        End If

    ElseIf keyChar = &quot;j&quot; or keyChar = &quot;о&quot; Then
        If APP() = &quot;CALC&quot; Then
	       	&apos;Print &quot;This is Calc&quot;
			If bExpand Then simulate_KeyPress_Char(&quot;DOWN&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;DOWN&quot;)
        Else
        If MODE = M_VISUAL_LINE Then
            &apos; If cursor is already on or bellow the Visual base line.
            If getCursor().getPosition().Y() &gt;= VISUAL_BASE.Y() Then
                &apos; If on Visual base line then format it for selecting bellow 
                &apos; lines.
                If VISUAL_BASE.Y() = getCursor().getPosition().Y() Then
                    getCursor().gotoStartOfLine(False)
                    getCursor().gotoEndOfLine(bExpand)
                    &apos; Move cursor to next line if not already there.
                    If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                        getCursor().goRight(1, bExpand)
                    End If

                End If

                If getCursor().goDown(1, bExpand) Then
                    getCursor().gotoStartOfLine(bExpand)

                &apos; If cursor is on last line then select from current position 
                &apos; to end of line.
                Else
                    getCursor().gotoEndOfLine(bExpand)
                End If

            &apos; If cursor is above the Visual base line.
            ElseIf getCursor().getPosition().Y() &lt; VISUAL_BASE.Y() Then
                &apos; Move cursor to start of bellow line.
                getCursor().goDown(1, bExpand)
                getCursor().gotoStartOfLine(bExpand)
            End If

        Else
        &apos; oTextCursor.goUp and oTextCursor.goDown SHOULD work, but doesn&apos;t (I dont know why).
        &apos; So this is a weird hack
            &apos;oTextCursor.goDown(1, False)
            getCursor().goDown(1, bExpand)
        End If
        bSetCursor = False
        End If
    &apos; ----------

    ElseIf keyChar = &quot;J&quot; or keyChar = &quot;О&quot; Then
	&apos; Select Previous Sheet&apos;
        If APP() = &quot;CALC&quot; Then
			simulate_KeyPress_Char(&quot;PAGEUP&quot;, &quot;CTRL&quot;)
        End If
    ElseIf keyChar = &quot;K&quot;  or keyChar = &quot;Л&quot; Then
	&apos; Select Next Sheet&apos;
        If APP() = &quot;CALC&quot; Then
			simulate_KeyPress_Char(&quot;PAGEDOWN&quot;, &quot;CTRL&quot;)
        End If
    ElseIf keyChar = &quot;0&quot;  and getRawMultiplier() = 0 Then
        if keyModifiers = 0 Then
        	If APP() &lt;&gt; &quot;CALC&quot; Then
				getCursor().gotoStartOfLine(bExpand)
				bSetCursor = False
			Else
				If bExpand Then simulate_KeyPress_Char(&quot;HOME&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;HOME&quot;)
        	End If
        End If
    ElseIf keyChar = &quot;^&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
        &apos; This variable represents the original line the cursor was on before 
        &apos; any of the following changes.
        dim oldLine
        oldLine = getCursor().getPosition().Y()

        &apos; Select all of the current line and put it into a string.
        getCursor().gotoEndOfLine(False)
        If getCursor().getPosition.Y() &gt; oldLine Then
            &apos; If gotoEndOfLine moved cursor to next line then move it back.
            getCursor().goLeft(1, False)
        End If
        getCursor().gotoStartOfLine(True)
        dim s as String
        s = getCursor().String

        &apos; Undo any changes made to the view cursor, then move to start of 
        &apos; line. This way any previous selction made by the user will remain.
        getCursor().gotoRange(oTextCursor, False)
        getCursor().gotoStartOfLine(bExpand)

        &apos; This integer will be used to determine the position of the first 
        &apos; character in the line that is not a space or a tab.
        dim i as Integer
        i = 1

        &apos; Iterate through the characters in the string until a character that 
        &apos; is not a space or a tab is found.
        Do While i &lt;= Len(s)
            dim c
            c = Mid(s,i,1)
            If c &lt;&gt; &quot; &quot; And c &lt;&gt; Chr(9) Then
                Exit Do
            End If
            i = i + 1
        Loop

        &apos; Move the cursor to the first non space/tab character.
        getCursor().goRight(i - 1, bExpand)
        bSetCursor = False
        Else
			If bExpand Then simulate_KeyPress_Char(&quot;HOME&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;HOME&quot;)
		End If

    ElseIf keyChar = &quot;$&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			dim oldPos, newPos
			oldPos = getCursor().getPosition()
			getCursor().gotoEndOfLine(bExpand)
			newPos = getCursor().getPosition()

			&apos; If the result is at the start of the line, then it must have
			&apos; jumped down a line; goLeft to return to the previous line.
			&apos;   Except for: Empty lines (check for oldPos = newPos)
			If getCursor().isAtStartOfLine() And oldPos.Y() &lt;&gt; newPos.Y() Then
				getCursor().goLeft(1, bExpand)
			End If

			&apos; maybe eventually cursorGoto... should return True/False for bsetCursor
			bSetCursor = False

		Else
			If bExpand Then simulate_KeyPress_Char(&quot;END&quot;, &quot;SHIFT&quot;) Else simulate_KeyPress_Char(&quot;END&quot;)
        End If
    ElseIf keyChar = &quot;G&quot; Then
		If APP() &lt;&gt; &quot;CALC&quot; Then
        If MODE = M_VISUAL_LINE Then
            &apos; If cursor is above Visual base line then move cursor down to it. 
            Do Until getCursor().getPosition.Y() &gt;= VISUAL_BASE.Y()
                getCursor().goDown(1, False)
            Loop
            &apos; If cursor is on Visual base line then move it to start of line.
            If getCursor().getPosition.Y() = VISUAL_BASE.Y() Then
                getCursor().gotoStartOfLine(False)
            End If
        End If
        getCursor().gotoEnd(bExpand)
        bSetCursor = False
		Else
			If bExpand Then simulate_KeyPress_Char(&quot;DOWN&quot;, &quot;SHIFT&quot;, &quot;CTRL&quot;) Else simulate_KeyPress_Char(&quot;DOWN&quot;, &quot;CTRL&quot;)
		End If

    ElseIf keyChar = &quot;w&quot; or keyChar = &quot;W&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
        &apos; For the case when the user enters &quot;cw&quot;:
        If getSpecial() = &quot;c&quot; Then
            &apos; If the cursor is on a word then delete from the current position to 
            &apos; the end of the word.
            &apos; If the cursor is not on a word then delete from the current position 
            &apos; to the start of the next word or until the end of the paragraph.

            If NOT oTextCursor.isEndOfParagraph() Then
               &apos; Move cursor to right in case it is already at start or end of 
               &apos; word.
               oTextCursor.goRight(1, bExpand)
            End If

            Do Until oTextCursor.isEndOfWord() Or oTextCursor.isStartOfWord() Or oTextCursor.isEndOfParagraph()
                oTextCursor.goRight(1, bExpand)
            Loop

        &apos; For the case when the user enters &quot;w&quot; or &quot;dw&quot;:
        Else
            &apos; Note: For &quot;w&quot;, using gotoNextWord would mean that the cursor 
            &apos; would not be moved to the next word when it involved moving down 
            &apos; a line and that line happened to begin with whitespace. It would 
            &apos; also mean that the cursor would not skip over lines that only 
            &apos; contain whitespace.

            If NOT (getSpecial() = &quot;d&quot; And oTextCursor.isEndOfParagraph()) Then
                &apos; Move cursor to right in case cursor is already at the start 
                &apos; of a word. 
                &apos; Additionally for &quot;w&quot;, move right in case already on an empty 
                &apos; line.
                oTextCursor.goRight(1, bExpand)
            End If

            &apos; Stop looping when the cursor reaches the start of a word, an empty 
            &apos; line, or cannot be moved further (reaches end of file).
            &apos; Additionally, if &quot;dw&quot; then stop looping if end of paragraph is reached.
            Do Until oTextCursor.isStartOfWord() Or (oTextCursor.isStartOfParagraph() And oTextCursor.isEndOfParagraph())
                &apos; If &quot;dw&quot; then do not delete past the end of the line
                If getSpecial() = &quot;d&quot; And oTextCursor.isEndOfParagraph() Then
                    Exit Do
                &apos; If &quot;w&quot; then stop advancing cursor if cursor can no longer 
                &apos; move right
                ElseIf NOT oTextCursor.goRight(1, bExpand) Then
                    Exit Do
                End If
            Loop
        End If
		Else
			If bExpand Then simulate_KeyPress_Char(&quot;RIGHT&quot;, &quot;SHIFT&quot;, &quot;CTRL&quot;) Else simulate_KeyPress_Char(&quot;RIGHT&quot;, &quot;CTRL&quot;)
        End If
    ElseIf keyChar = &quot;b&quot; or keyChar = &quot;B&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
        &apos; When the user enters &quot;b&quot;, &quot;cb&quot;, or &quot;db&quot;:

        &apos; Note: The function gotoPreviousWord causes a lot of problems when 
        &apos; trying to emulate vim behavior. The following method doesn&apos;t have to 
        &apos; account for as many special cases.

        &apos; &quot;b&quot;: Moves the cursor to the start of the previous word or until an empty 
        &apos; line is reached.

        &apos; &quot;db&quot;: Does same thing as &quot;b&quot; only it deletes everything between the 
        &apos; orginal cursor position and the new cursor position. The exception to 
        &apos; this is that if the original cursor position was at the start of a 
        &apos; paragraph and the new cursor position is on a separate paragraph with 
        &apos; at least two words then don&apos;t delete the new line char to the &quot;left&quot; 
        &apos; of the original paragraph.

        &apos; &quot;dc&quot;: Does the same as &quot;db&quot; only the new line char described in &quot;db&quot; 
        &apos; above is never deleted.


        &apos; This variable is used to tell whether or not we need to make a 
        &apos; distinction between &quot;b&quot;, &quot;cb&quot;, and &quot;db&quot;.
        dim dc_db as boolean

        &apos; Move cursor to left in case cursor is already at the start of a word 
        &apos; or on on an empty line. If cursor can move left and user enterd &quot;dc&quot; 
        &apos; or &quot;db&quot; and the cursor was originally on the start of a paragraph 
        &apos; then set dc_db to true and unselect the new line character separating 
        &apos; the paragraphs. If cursor can&apos;t move left then there is no line above 
        &apos; the current one and no need to make a distinction between &quot;b&quot;, &quot;cb&quot;, 
        &apos; and &quot;db&quot;.
        dc_db = False
        If oTextCursor.isStartOfParagraph() And oTextCursor.goLeft(1, bExpand) Then
            If getSpecial() = &quot;c&quot; Or getSpecial() = &quot;d&quot; Then
                dc_db = True
                &apos; If all conditions above are met then unselect the \n char.
                oTextCursor.collapseToStart()
            End If
        End If

        &apos; Stop looping when the cursor reaches the start of a word, an empty 
        &apos; line, or cannot be moved further (reaches start of file).
        Do Until oTextCursor.isStartOfWord() Or (oTextCursor.isStartOfParagraph() And oTextCursor.isEndOfParagraph())
            &apos; Stop moving cursor if cursor can no longer move left
            If NOT oTextCursor.goLeft(1, bExpand) Then
                Exit Do
            End If
        Loop

        If dc_db Then
            &apos; Make a clone of oTextCursor called oTextCursor2 and use it to 
            &apos; check if there are at least two words in the &quot;new&quot; paragraph. 
            &apos; If there are &lt;2 words then the loop will stop when the cursor 
            &apos; cursor reaches the start of a paragraph. If there &gt;=2 words then 
            &apos; then the loop will stop when the cursor reaches the end of a word.
            dim oTextCursor2
            oTextCursor2 = getCursor().getText.createTextCursorByRange(oTextCursor)
            Do Until oTextCursor2.isEndOfWord() Or oTextCursor2.isStartOfParagraph()
                oTextCursor2.goLeft(1, bExpand)
            Loop
            &apos; If there are less than 2 words on the &quot;new&quot; paragraph then set 
            &apos; oTextCursor to oTextCursor 2. This is because vim&apos;s behavior is 
            &apos; to clear the &quot;new&quot; paragraph under these conditions.
            If oTextCursor2.isStartOfParagraph() Then
                oTextCursor = oTextCursor2
                oTextCursor.gotoRange(oTextCursor.getStart(), bExpand)
                &apos; If user entered &quot;db&quot; then reselect the \n char from before.
                If getSpecial() = &quot;d&quot; Then
                    oTextCursor.goRight(1, bExpand)
                End If
            End If
        End If
		Else
			If bExpand Then simulate_KeyPress_Char(&quot;LEFT&quot;, &quot;SHIFT&quot;, &quot;CTRL&quot;) Else simulate_KeyPress_Char(&quot;LEFT&quot;, &quot;CTRL&quot;)
        End If
    ElseIf keyChar = &quot;e&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
        &apos; When the user enters &quot;e&quot;, &quot;ce&quot;, or &quot;de&quot;:

        &apos; Note: The function gotoNextWord causes a lot of problems when trying 
        &apos; to emulate vim behavior. The following method doesn&apos;t have to account 
        &apos; for as many special cases.

        &apos; Moves the cursor to the end of the next word or end of file if there 
        &apos; are no more words.

        &apos; Move cursor to right by two in case cursor is already at vim&apos;s 
        &apos; definition of endOfWord.
        oTextCursor.goRight(2, bExpand)

        &apos; If moving cursor to right by 2 places cursor just to the right of a 
        &apos; &quot;.&quot; then move cursor right again. This is needed to ensure that the 
        &apos; cursor does not get stuck.
        getCursor().gotoRange(oTextCursor.getEnd(), False)
        getCursor().goLeft(1, True)
        If getCursor().String = &quot;.&quot; Then
            oTextCursor.goRight(1, bExpand)
        End If

        &apos; gotoEndOfWord gets stuck sometimes so manually moving the cursor 
        &apos; right is necessary in these cases.
        Do Until oTextCursor.gotoEndOfWord(bExpand)
            &apos; If cursor can no longer move right then break loop
            If NOT oTextCursor.goRight(1, bExpand) Then
                Exit Do
            End If
        Loop

        If oTextCursor.isEndOfWord() Then
            &apos; LibreOffice defines a &quot;.&quot; directly following a word to be the 
            &apos; endOfWord and vim does not. So in this case we need to move the 
            &apos; the cursor to the left.
            getCursor().gotoRange(oTextCursor.getEnd(), False)
            getCursor().goLeft(1, True)
            If getCursor().String = &quot;.&quot; Then
                oTextCursor.goLeft(1, bExpand)
            End If

            &apos; gotoEndOfWord moves the cursor one character further than vim 
            &apos; does so move it back one if end of word is reached and not 
            &apos; expanding selection.
            If NOT bExpand Then
                oTextCursor.goLeft(1, bExpand)
            End If
        End If
        End If

    ElseIf keyChar = &quot;E&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
        oTextCursor.gotoPreviousWord(bExpand)
        oTextCursor.gotoPreviousWord(bExpand)
        oTextCursor.gotoEndOfWord(bExpand)
        End If
    ElseIf keyChar = &quot;)&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			oTextCursor.gotoNextSentence(bExpand)
        End If
    ElseIf keyChar = &quot;(&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			oTextCursor.gotoPreviousSentence(bExpand)
        End If
    ElseIf keyChar = &quot;}&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			oTextCursor.gotoNextParagraph(bExpand)
        End If
    ElseIf keyChar = &quot;{&quot; Then
        If APP() &lt;&gt; &quot;CALC&quot; Then
			oTextCursor.gotoPreviousParagraph(bExpand)
        End If

    Else
        bSetCursor = False
        bMatched = False
    End If

    &apos; If oTextCursor was moved, set global cursor to its position
    If APP() &lt;&gt; &quot;CALC&quot; Then

	If bSetCursor Then
		getCursor().gotoRange(oTextCursor.getStart(), False)

		&apos; ---- REALLY BAD HACK
		&apos; I can&apos;t seem to get the View Cursor (getCursor()) to update its
		&apos; position without calling its own movement functions.
		&apos; Theoretically, the above call to gotoRange should work, but I don&apos;t
		&apos; know why it doesn&apos;t. Visually it works, but its X position is reset
		&apos; when you move lines. Bug??

		&apos; dim oTempPos
		&apos; oTempPos = getCursor().getPosition()
		&apos; &apos; Move left 1 and then right 1 to stay in same position
		&apos; getCursor().goLeft(1, False)
		&apos; If Not samePos(oTempPos, getCursor().getPosition()) Then
		&apos; 	getCursor().goRight(1, False)
		&apos; End If
	End If


	&apos; If oTextCursor was moved and is in VISUAL mode, update selection
	If bSetCursor and bExpand then
		thisComponent.getCurrentController.Select(oTextCursor)
	End If

    End If

    ProcessMovementKey = bMatched
End Function

Function APP() as String
	If thisComponent.VBAGlobalConstantName = &quot;ThisExcelDoc&quot; Then
		APP = &quot;CALC&quot;
	ElseIf thisComponent.VBAGlobalConstantName = &quot;ThisWordDoc&quot; Then
		APP = &quot;WRITER&quot;
	Else
		&apos; Drawing, Presentations, etc
		APP = &quot;UNK&quot;
	End If
End Function

Sub sStartViewEventListener
	sStopViewEventListener()
	oListener = CreateUnoListener(&quot;VEListener_&quot;, &quot;com.sun.star.document.XEventListener&quot;)
	dim oGlobalEventBroadcaster
	oGlobalEventBroadcaster = GetDefaultContext().getByName(&quot;/singletons/com.sun.star.frame.theGlobalEventBroadcaster&quot;)
	oGlobalEventBroadcaster.addEventListener(oListener)
End Sub


Sub sStopViewEventListener
	dim oGlobalEventBroadcaster
	oGlobalEventBroadcaster = GetDefaultContext().getByName(&quot;/singletons/com.sun.star.frame.theGlobalEventBroadcaster&quot;)
	oGlobalEventBroadcaster.removeEventListener(oListener)
End Sub


Sub VEListener_notifyEvent(o)
    &apos; Exit if plugin is not enabled
    If MODE = M_DISABLED Then
        KeyHandler_KeyPressed = False
        Exit Sub
    End If
    
	If o is Nothing Then
		Exit Sub
	End If
	dim oSource as object
	oSource = o.Source
	If oSource is Nothing Then
		Exit Sub
	End If	
    If APP() = &quot;CALC&quot; Then
		dim bHasInterface
		bHasInterface = HasUnoInterfaces(oSource, &quot;com.sun.star.text.XTextDocument&quot;)
		If not bHasInterface Then	
			Exit Sub
		End If
	End If
	dim oController as object
	If o.EventName = &quot;OnFocus&quot; Then
		reinitVibreoffice()
	ElseIf o.EventName = &quot;OnViewCreated&quot; Then
		oController = oSource.getCurrentController()
		If not (oController is Nothing) Then
			oController.addKeyHandler(oXKeyHandler)
		End If
	ElseIf o.EventName = &quot;OnViewClosed&quot; Then
		oController = oSource.getCurrentController()
		If not (oController is Nothing) Then
			oController.removeKeyHandler(oXKeyHandler)
		End If
	End If
End Sub


sub VEListener_disposing()
end sub


Sub reinitVibreoffice
    dim oTextCursor, oCurrentController
    oCurrentController = getCurrentController()
    If oCurrentController is Nothing Then
    	Exit Sub
    End If

    resetMultiplier()
    setCursor()
    setTextCursor()
    gotoMode(M_NORMAL)

    &apos; Show terminal cursor
    oTextCursor = getTextCursor()
    If not (oTextCursor Is Nothing) Then
        cursorReset(oTextCursor)
    End If
End Sub

Sub startVibreoffice()
	If not VIBREOFFICE_STARTED Then
    	sStartXKeyHandler()
    
    	VIBREOFFICE_STARTED = True
		gotoMode(M_NORMAL)
		
		oCurrentFrame = StarDesktop().getCurrentFrame()
    End If
    
    reinitVibreoffice()
    getCurrentController().addKeyHandler(oXKeyHandler)
End Sub


Sub stopVibreoffice()
    restoreStatus()
    getCurrentController().removeKeyHandler(oXKeyHandler)
End Sub


Sub toggleVibreoffice()
    if MODE = M_DISABLED then
    	gotoMode(OLD_MODE)
    else
	    OLD_MODE = MODE
	    gotoMode(M_DISABLED)
    end if
End Sub
</script:module>